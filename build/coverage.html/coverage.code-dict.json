{"/home/travis/build/npmtest/node-npmtest-ascoltatori/test.js":"/* istanbul instrument in package npmtest_ascoltatori */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/lib.npmtest_ascoltatori.js":"/* istanbul instrument in package npmtest_ascoltatori */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ascoltatori = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ascoltatori = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ascoltatori && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ascoltatori */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ascoltatori\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ascoltatori.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ascoltatori.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ascoltatori.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ascoltatori.__dirname + '/lib.npmtest_ascoltatori.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/index.js":"\nmodule.exports = require(\"./lib/ascoltatori\");\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/ascoltatori.js":"\"use strict\";\n\nvar SubsCounter = require(\"./subs_counter\");\nvar util = require(\"./util\");\n\n/**\n * You can require any Ascolatore through this module.\n *\n * @api public\n */\nmodule.exports.AbstractAscoltatore = require('./abstract_ascoltatore');\nmodule.exports.TrieAscoltatore = require('./trie_ascoltatore');\nmodule.exports.EventEmitter2Ascoltatore = require('./event_emitter2_ascoltatore');\nmodule.exports.RedisAscoltatore = require(\"./redis_ascoltatore\");\nmodule.exports.ZeromqAscoltatore = require(\"./zeromq_ascoltatore\");\nmodule.exports.AMQPAscoltatore = require(\"./amqp_ascoltatore\");\nmodule.exports.AMQPLibAscoltatore = require(\"./amqplib_ascoltatore\");\nmodule.exports.MQTTAscoltatore = require(\"./mqtt_ascoltatore\");\nmodule.exports.PrefixAscoltatore = require(\"./prefix_acoltatore\");\nmodule.exports.MongoAscoltatore = require('./mongo_ascoltatore');\nmodule.exports.DecoratorAscoltatore = require(\"./decorator_ascoltatore\");\nmodule.exports.JSONAscoltatore = require(\"./json_ascoltatore\");\nmodule.exports.FileSystemAscoltatore = require(\"./filesystem_ascoltatore\");\nmodule.exports.KafkaAscoltatore = require(\"./kafka_ascoltatore\");\n\n/**\n *\n * @api private\n */\nvar classes = {\n  \"amqp\": module.exports.AMQPAscoltatore,\n  \"amqplib\": module.exports.AMQPLibAscoltatore,\n  \"trie\": module.exports.TrieAscoltatore,\n  \"eventemitter2\": module.exports.EventEmitter2Ascoltatore,\n  \"mqtt\": module.exports.MQTTAscoltatore,\n  \"redis\": module.exports.RedisAscoltatore,\n  \"zmq\": module.exports.ZeromqAscoltatore,\n  \"mongo\": module.exports.MongoAscoltatore,\n  \"kafka\": module.exports.KafkaAscoltatore,\n  \"filesystem\": module.exports.FileSystemAscoltatore\n};\n\n/**\n * Builds an ascolatore based on the proper type.\n * It will encapsulate it in a PrefixAscolatore if a prefix key is\n * present.\n * The other options are passed through the constructor of the\n * Ascoltatore\n * \n * Options:\n *  - `type`, it can be \"amqp\", \"trie\", \"eventemitter2\", \"redis\", \"zmq\", or just a class\n *    that will be instantiated (i.e. with `new`).\n *  - `prefix`, will be passed to the PrefixAscoltatore.\n *  - `json`, it can be setted to false if you do not want your messages\n *    to be wrapped inside JSON.\n *  - any other option that the ascolatore constructor may need.\n *\n *  @api public\n *  @param {Object} opts The options\n *  @param {Function} done The callback that will be called when the\n *  ascoltatore will be ready\n */\nmodule.exports.build = function build(opts, done) {\n  opts = opts || {};\n\n  if (typeof opts === \"function\") {\n    done = opts;\n    opts = {};\n  }\n\n  var Klass = null,\n    result = null;\n\n  Klass = (typeof opts.type === 'function') ? opts.type :\n            (classes[opts.type] || module.exports.TrieAscoltatore);\n\n  result = new Klass(opts, module.exports);\n\n  if (opts.prefix) {\n    result = new module.exports.PrefixAscoltatore(opts.prefix, result)\n      .once(\"error\", done);\n  }\n\n  if (opts.json !== false) {\n    result = new module.exports.JSONAscoltatore(result)\n      .once(\"error\", done);\n  }\n\n  if (done) {\n    setImmediate(function() {\n      result.once(\"ready\", function() {\n        result.removeListener(\"error\", done);\n        done(null, result);\n      });\n    });\n  }\n\n  return result;\n};\n\n/**\n * These are just utilities\n *\n * @api private\n */\nmodule.exports.SubsCounter = SubsCounter;\nmodule.exports.util = util;\n\n/**\n * You can require a shared mocha test to you if you want to develop\n * a custom Ascoltatore inside your app.\n *\n * @api public\n */\nmodule.exports.behaveLikeAnAscoltatore = require(\"./behave_like_an_ascoltatore\");\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/subs_counter.js":"\"use strict\";\n\n/**\n * This is a counter for the subscriptions.\n * It is used by all the ascoltatori to keep track to\n * for what topics there are subscribers.\n *\n * @api public\n */\nfunction SubsCounter() {\n  this.clear();\n}\n\n/**\n * Clear the SubsCounter\n *\n * @api public\n */\nSubsCounter.prototype.clear = function() {\n  this._length = 0;\n  this._obj = {};\n  return this;\n};\n\n/**\n * Add a new element to the SubsCounter.\n * The SubsCounter keep track of the number of times\n * this method was called for every passed `elem`.\n *\n * @param {String} elem The element to track\n * @return {SubsCounter}\n * @api public\n */\nSubsCounter.prototype.add = function(elem) {\n  if (!this.include(elem)) {\n    this._length += 1;\n    this._obj[elem] = 1;\n  } else {\n    this._obj[elem] = this._obj[elem] + 1;\n  }\n\n  return this;\n};\n\n/**\n * Removes an element.\n * The SubsCounter keep track of the total\n * times an `elem` is added or removed.\n *\n * @api public\n * @param {String} elem The element to track\n * @return {SubsCounter}\n */\nSubsCounter.prototype.remove = function(elem) {\n  if (!this.include(elem)) {\n    return this;\n  }\n\n  if (this._obj[elem] === 1) {\n    this._length -= 1;\n    delete this._obj[elem];\n  } else {\n    this._obj[elem] = this._obj[elem] - 1;\n  }\n\n  return this;\n};\n\n/**\n * The SubsCounter keep track of the total\n * times an `elem` is added or removed, and it\n * offers the `include` method to verify if it is\n * greater than zero.\n *\n * @param {String} elem The element to track\n * @return {boolean} true if the element has more than one subscription\n * @api public\n */\nSubsCounter.prototype.include = function(elem) {\n  return this._obj[elem] !== undefined;\n};\n\n\n/**\n * List all the elements for which `include` returns true.\n *\n * @api public\n * @param {Function} callback the function where the elements will be\n * yield\n * @return {SubsCounter}\n */\nSubsCounter.prototype.forEach = function(callback) {\n  var key = null;\n  for (key in this._obj) {\n    if (this._obj.hasOwnProperty(key)) {\n      callback(key);\n    }\n  }\n\n  return this;\n};\n\n/**\n * List all the elements for which `include` returns true.\n *\n * @api public\n * @return {Array} a list of elements\n */\nSubsCounter.prototype.keys = function() {\n  var array = [];\n  this.forEach(function(e) {\n    array.push(e);\n  });\n  return array;\n};\n\n/**\n * Returns the number of elements for which `include` returns true.\n *\n * @api public\n * @return {Number} \n */\nSubsCounter.prototype.__defineGetter__(\"length\", function() {\n  return this._length;\n});\n\nmodule.exports = SubsCounter;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/util.js":"\"use strict\";\n\nvar util = require('util');\nvar uuid = require(\"uuid\");\nvar steed = require(\"steed\");\n\n/**\n * A function to build an unique identifier.\n * @api public\n */\nfunction buildIdentifier() {\n  var result = util.format('asc_%s', uuid.v1());\n  return result;\n}\nmodule.exports.buildIdentifier = buildIdentifier;\n\n/**\n * Alias two methods from the same object\n *\n * @api public\n * @param {Object} obj The object\n * @param {String} from The source property name\n * @param {String} to The destination property name\n */\nfunction alias(obj, from, to) {\n  if (typeof obj[from] !== 'function') {\n    throw util.format(\"'%s' is not a function\", from);\n  }\n  obj[to] = obj[from];\n  return obj;\n}\nmodule.exports.alias = alias;\n\n/**\n * The list of common aliases for all ascoltatori.\n *\n * @api public\n */\nvar aliases = {\n  publish: [\"pub\"],\n  subscribe: [\"sub\"],\n  unsubscribe: [\"unsub\"]\n};\n\n/**\n * Applies the `aliases` list to an ascoltatore.\n *\n * @param {AbstractAscoltatore} obj The ascolatore\n * @api public\n */\nfunction aliasAscoltatore(obj) {\n  var key = null;\n  Object.keys(aliases).forEach(function(key) {\n    if (aliases.hasOwnProperty(key)) {\n      aliases[key].forEach(function(a) {\n        module.exports.alias(obj, key, a);\n      });\n    }\n  });\n  return obj;\n}\nmodule.exports.aliasAscoltatore = aliasAscoltatore;\n\n/**\n * Wrap a function in another function, which might\n * be null.\n *\n * @api public\n * @param {Function} done the funcion to be wrapped.\n */\nfunction wrap(done) {\n  return function() {\n    if (typeof done === 'function') {\n      done();\n    }\n  };\n}\nmodule.exports.wrap = wrap;\n\nfunction defer (done) {\n  if (typeof done === \"function\") {\n    setImmediate(done);\n  }\n}\nmodule.exports.defer = defer;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/abstract_ascoltatore.js":"\"use strict\";\n\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * An `AbstractAscoltatore` is a class that inherits from `EventEmitter`.\n * It is also the base class of `ascoltatori`. It is not meant to be used alone,\n * but it defines the interface for every ascoltatore.\n *\n * Every ascoltatore emits the following events:\n *  - `ready`, when the ascolatore is ready for subscribing and/or\n *     publishing messages;\n *  - `closed`, when the ascoltatore has closed all the connections\n *     and therefore it cannot accept new messages;\n *  - `error`, if something goes wrong.\n *\n * @api public\n */\nfunction AbstractAscoltatore(settings, nativeSettings) {\n  EventEmitter.call(this);\n\n  settings = settings || {};\n  nativeSettings = nativeSettings || {};\n\n  this._separator = settings.separator || '/',\n  this._wildcardOne = settings.wildcardOne || '+',\n  this._wildcardSome = settings.wildcardSome || '*';\n  this._nativeSettings = nativeSettings;\n\n  if (nativeSettings.separator && \n      (this._separator !== nativeSettings.separator)) {\n    this._reInSeparator = new RegExp('\\\\' + this._separator, 'g');\n    this._reOutSeparator = new RegExp('\\\\' + nativeSettings.separator, 'g');\n  }\n  if (nativeSettings.wildcardOne &&\n      (this._wildcardOne !== nativeSettings.wildcardOne)) {\n    this._reInWildcardOne = new RegExp('\\\\' + this._wildcardOne, 'g');\n  }\n  if (nativeSettings.wildcardSome &&\n      (this._wildcardSome !== nativeSettings.wildcardSome)) {\n    this._reInWildcardSome = new RegExp('\\\\' + this._wildcardSome, 'g');\n  }\n\n  this._setPublish();\n\n  this._ready = false;\n  this._closed = false;\n\n  var that = this;\n\n  this.on(\"ready\", function() {\n    that._ready = true;\n  });\n\n  this.on(\"closed\", function() {\n    that._closed = true;\n  });\n\n  this.on(\"newListener\", function(event, listener) {\n    if (event === \"ready\" && that._ready) {\n      listener();\n    }\n  });\n\n  this.setMaxListeners(0);\n}\n\nAbstractAscoltatore.prototype = Object.create(EventEmitter.prototype);\n\nAbstractAscoltatore.prototype._raiseIfClosed = function raiseIfClosed() {\n  if (this._closed) {\n    throw new Error(\"This ascoltatore is closed\");\n  }\n};\n\n/**\n * This method provides a way for users to subscribe for messages.\n *\n * The messages are published on topics, that is just a \"path\", e.g.\n * `/this/is/a/topic`.\n * The topic are organized in a hierarchy, and `subscribe` support the usage\n * of wildcards, e.g. you can subscribe to `*` and it will\n * match all the topics \n *\n * Example:\n *       ascoltatore.subscribe(\"*\", function () {\n *         // this will print { '0': \"hello/42\", '1': \"a message\" }\n *         console.log(arguments); \n *       });\n *\n * @param {String} topic the topic to subscribe to\n * @param {Function} callback the callback that will be called when a new message is published.\n * @param {Function} done the callback that will be called when the subscribe is completed\n * @api public\n */\nAbstractAscoltatore.prototype.subscribe = function(topic, callback, done) {\n  throw new Error(\"Subclass to implement\");\n};\n\n/**\n * This method allow publishing of messages to topics.\n *\n * Example:\n *     ascoltatore.publish(\"hello/42\", \"a message\", function () {\n *       console.log(\"message published\");\n *     });\n *\n *\n * @param {String} topic the topic to publish to\n * @param {Object} payload the callback that will be called when a new message is published.\n * @param {Object} options (optional) Metadata associated with the message (e.g. qos, messageId). If you only specify 3 parameters to your method then you won't be passed this parameter.\n * @param {Function} done the callback that will be called after the message has been published.\n * @api public\n */\nAbstractAscoltatore.prototype.publish = function(topic, payload, options, done) {\n  throw new Error(\"Subclass to implement\");\n};\n\nAbstractAscoltatore.prototype._setPublish = function() {\n  var proto = Object.getPrototypeOf(this),\n      f = proto.publish,\n      publish,\n      newPublish;\n\n  if (!f) { return; }\n\n  if (f.length === 4) {\n    publish = this.publish;\n  } else {\n    publish = function (topic, payload, options, done) {\n      return f.call(this, topic, payload, done);\n    };\n  }\n\n  newPublish = function (topic, payload, options, done) {\n    if ((typeof options === 'function') ||\n        (done && (typeof done !== 'function'))) {\n      done = options;\n      options = {};\n    } else if ((options === undefined) || (options === null)) {\n      options = {};\n    }\n\n    return publish.call(this, topic, payload, options, done);\n  };\n\n  this.publish = newPublish;\n\n  if (proto.pub === proto.publish) {\n    this.pub = newPublish;\n  }\n};\n\n/**\n * This method provides the inverse of subscribe.\n *\n * @param {String} topic the topic from which to unsubscribe\n * @param {Function} callback the callback that will be unsubscribed\n * @param {Function} done the callback that will be called when the unsubscribe is completed\n * @api public\n */\nAbstractAscoltatore.prototype.unsubscribe = function(topic, callback, done) {\n  throw new Error(\"Subclass to implement\");\n};\n\n/**\n * This method closes the Ascoltatore.\n * After this method is called every call to subscribe or publish will raise\n * an exception\n *\n * @param {Function} done the callback that will be called when Ascoltatore is closed\n * @api public\n */\nAbstractAscoltatore.prototype.close = function(done) {\n  throw new Error(\"Subclass to implement\");\n};\n\nAbstractAscoltatore.prototype._subTopic = function(topic) {\n  if (this._reInSeparator) {\n    topic = topic.replace(this._reInSeparator,\n                          this._nativeSettings.separator);\n  }\n  if (this._reInWildcardSome) {\n    topic = topic.replace(this._reInWildcardSome,\n                          this._nativeSettings.wildcardSome);\n  }\n  if (this._reInWildcardOne) {\n    topic = topic.replace(this._reInWildcardOne,\n                          this._nativeSettings.wildcardOne);\n  }\n  return topic;\n};\n\nAbstractAscoltatore.prototype._recvTopic = function(topic) {\n  if (this._reOutSeparator) {\n    topic = topic.replace(this._reOutSeparator, this._separator);\n  }\n  return topic;\n};\n\nAbstractAscoltatore.prototype._pubTopic = function(topic) {\n  if (this._reInSeparator) {\n    topic = topic.replace(this._reInSeparator,\n                          this._nativeSettings.separator);\n  }\n  return topic;\n};\n\n/**\n * Exports the AbstractAscoltatore;\n *\n * @api public\n */\nmodule.exports = AbstractAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/trie_ascoltatore.js":"\"use strict\";\n\nvar AbstractAscoltatore = require(\"./abstract_ascoltatore\");\nvar util = require(\"./util\");\nvar defer = util.defer;\nvar debug = require(\"debug\")(\"ascoltatori:trie\");\nvar Qlobber = require(\"qlobber\").Qlobber;\nvar ascoltatori = require('./ascoltatori');\n\n/**\n * A TrieAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is backed by a Qlobber.\n *\n * @api public\n */\nfunction TrieAscoltatore(settings) {\n  AbstractAscoltatore.call(this, settings);\n\n  settings = settings || {};\n\n  this._matcher = new Qlobber({\n    separator: settings.separator || '/',\n    wildcard_one: settings.wildcardOne || '+',\n    wildcard_some: settings.wildcardSome || '*'\n  });\n\n  this.emit(\"ready\");\n}\n\n\n/**\n * See AbstractAscoltatore for the public API definitions.\n *\n * @api private\n */\n\nTrieAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\nTrieAscoltatore.prototype.subscribe = function subscribe(topic, callback, done) {\n  this._raiseIfClosed();\n  debug(\"registered new subscriber for topic \" + topic);\n\n  this._matcher.add(topic, callback);\n  defer(done);\n};\n\nTrieAscoltatore.prototype.publish = function (topic, message, options, done) {\n  this._raiseIfClosed();\n  debug(\"new message published to \" + topic);\n\n  var cbs = this._matcher.match(topic);\n\n  for (var i = 0; i < cbs.length; i++) {\n    cbs[i](topic, message, options);\n  }\n\n  defer(done);\n};\n\nTrieAscoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  debug(\"deregistered subscriber for topic \" + topic);\n\n  this._matcher.remove(topic, callback);\n\n  defer(done);\n};\n\nTrieAscoltatore.prototype.close = function close(done) {\n  this._matcher.clear();\n  this.emit(\"closed\");\n\n  debug(\"closed\");\n\n  defer(done);\n};\n\nutil.aliasAscoltatore(TrieAscoltatore.prototype);\n\n/**\n * Exports the TrieAscoltatore.\n *\n * @api public\n */\nmodule.exports = TrieAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/event_emitter2_ascoltatore.js":"\"use strict\";\n\nvar AbstractAscoltatore = require(\"./abstract_ascoltatore\");\nvar util = require(\"./util\");\nvar defer = util.defer;\nvar debug = require(\"debug\")(\"ascoltatori:ee2\");\nvar EventEmitter2 = require(\"eventemitter2\").EventEmitter2;\nvar ascoltatori = require('./ascoltatori');\n\n/**\n * A EventEmitter2Ascoltatore is a class that inherits from AbstractAscoltatore.\n * It is backed by EventEmitter2.\n *\n * @api public\n */\nfunction EventEmitter2Ascoltatore(settings) {\n  AbstractAscoltatore.call(this, settings, {\n    wildcardOne: '*',\n    wildcardSome: '**'\n  });\n\n  this._event = new EventEmitter2({\n    delimiter: this._separator,\n    wildcard: true\n  });\n\n  this._event.setMaxListeners(0);\n\n  this.emit(\"ready\");\n}\n\n\n/**\n * See AbstractAscoltatore for the public API definitions.\n *\n * @api private\n */\n\nEventEmitter2Ascoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\nEventEmitter2Ascoltatore.prototype.subscribe = function subscribe(topic, callback, done) {\n  this._raiseIfClosed();\n  debug(\"registered new subscriber for topic \" + topic);\n\n  this._event.on(this._subTopic(topic).replace(/^\\//g, ''), callback);\n  defer(done);\n};\n\nEventEmitter2Ascoltatore.prototype.publish = function (topic, message, options, done) {\n  this._raiseIfClosed();\n  debug(\"new message published to \" + topic);\n\n  this._event.emit(this._pubTopic(topic).replace(/^\\//g, ''), topic, message, options);\n\n  defer(done);\n};\n\nEventEmitter2Ascoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  debug(\"deregistered subscriber for topic \" + topic);\n\n  this._event.off(this._subTopic(topic).replace(/^\\//g, ''), callback);\n\n  defer(done);\n};\n\nEventEmitter2Ascoltatore.prototype.close = function close(done) {\n  this._event.removeAllListeners();\n  this.emit(\"closed\");\n\n  debug(\"closed\");\n\n  defer(done);\n};\n\nutil.aliasAscoltatore(EventEmitter2Ascoltatore.prototype);\n\n/**\n * Exports the EventEmitter2Ascoltatore.\n *\n * @api public\n */\nmodule.exports = EventEmitter2Ascoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/redis_ascoltatore.js":"\"use strict\";\n\nvar Redis = require('ioredis');\nvar msgpack = require('msgpack-lite');\nvar util = require(\"./util\");\nvar wrap = util.wrap;\nvar defer = util.defer;\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar SubsCounter = require(\"./subs_counter\");\nvar debug = require(\"debug\")(\"ascoltatori:redis\");\n\n/**\n * RedisAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is implemented through the `node_redis` package and it could be\n * backed up by any redis version greater than 2.2.\n *\n * The RedisAscoltatore defines two\n * properties _sub and _pub for handling\n * the two connections needed by redis.\n *\n * The options are:\n *  - `port`, the optional port to connect to;\n *  - `host`, the optional host to connect to;\n *  - `db`, the database to connect to (defaults to 0);\n *  - `password`, the optional password to use;\n *  - `sub_conn`, the optional redis connection to use for the sub and psub commands;\n *  - `pub_conn`, the optional redis connection to use for the pub command;\n *  - `redis`, the redis module (it will automatically be required if not present).\n *\n * @api public\n * @param {Object} opts The options object\n */\nfunction RedisAscoltatore(opts) {\n  AbstractAscoltatore.call(this, opts, {\n    separator: '/',\n    wildcardOne: '*',\n    wildcardSome: '*'\n  });\n\n  this._ready_sub = false;\n  this._ready_pub = false;\n  this._opts = opts || {};\n\n  this._ascoltatores = {};\n\n  this._startSub();\n  this._startPub();\n\n  this._subs_counter = new SubsCounter();\n}\n\n/**\n * Create a connection to redis using a default\n * from the opts if there is.\n *\n * @param {Object} opts The options object\n * @param {String} connName The name of the connection\n * @api private\n */\nfunction createConn(opts, connName) {\n  var conn = opts[connName];\n  if (conn === undefined) {\n    debug(\"connecting with \", opts);\n    conn = new Redis(opts);\n  }\n  return conn;\n}\n\n/**\n * Inheriting\n *\n * @api private\n */\nRedisAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\n/**\n * Start the pub connection\n *\n * @api private\n */\nRedisAscoltatore.prototype._startPub = function() {\n  var that = this;\n  if (this._client === undefined) {\n    this._client = createConn(this._opts, 'client_conn');\n    this._client.on(\"ready\", function() {\n      debug(\"created pub connection\");\n      that._updateReady(\"_ready_pub\");\n    });\n  }\n  return this._client;\n};\n\n/**\n * Start the sub connection\n *\n * @api private\n */\nRedisAscoltatore.prototype._startSub = function() {\n  var that = this,\n    handler = null;\n\n  if (this._sub === undefined) {\n    this._sub = createConn(this._opts, 'sub_conn');\n    this._sub.on(\"ready\", function() {\n      debug(\"created sub connection\");\n      that._updateReady(\"_ready_sub\");\n    });\n\n    handler = function(sub, topic, payload) {\n      topic = topic.toString(); // cast to string in case of Buffer instance (nodejs-redis >=2.0)\n      debug(\"new message received for topic \" + topic);\n      defer(function() {\n        // we need to skip out this callback, so we do not\n        // break the client when an exception occurs\n        var ascoltatore = that._ascoltatores[sub];\n        topic = topic.replace(new RegExp('/$'), '');\n        topic = that._recvTopic(topic);\n\n        payload = msgpack.decode(payload);\n        \n        if (ascoltatore) {\n          ascoltatore.publish(topic, payload.message, payload.options);\n        } else {\n          debug(\"no ascoltatore for subscription: \" + sub);\n        }\n      });\n    };\n\n    this._sub.on(\"messageBuffer\", function (topic, message) {\n      handler(topic, topic, message);\n    });\n    this._sub.on(\"pmessageBuffer\", function(sub, topic, message) {\n      handler(sub, topic, message);\n    });\n  }\n\n  return this._sub;\n};\n\nRedisAscoltatore.prototype._updateReady = function updateReady(key) {\n  this[key] = true;\n  if (this._ready_pub && this._ready_sub) {\n    this.emit(\"ready\");\n  }\n};\n\nRedisAscoltatore.prototype._containsWildcard = function(topic) {\n  return (topic.indexOf(this._wildcardOne) >= 0) ||\n         (topic.indexOf(this._wildcardSome) >= 0);\n};\n\nRedisAscoltatore.prototype.subscribe = function subscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  var newDone = function() {\n    debug(\"registered new subscriber for topic \" + topic);\n    defer(done);\n  };\n\n  var subTopic = this._subTopic(topic);\n\n  if (!subTopic.match(new RegExp('[/*]$'))) {\n    subTopic += '/';\n  }\n\n  if (this._containsWildcard(topic)) {\n    this._sub.psubscribe(subTopic, newDone);\n  } else {\n    this._sub.subscribe(subTopic, newDone);\n  }\n\n  debug(\"redis subscription topic is \" + subTopic);\n  this._subs_counter.add(subTopic);\n\n  var ascoltatore = this._ascoltatores[subTopic];\n\n  if (!ascoltatore) {\n    ascoltatore = this._ascoltatores[subTopic] = new TrieAscoltatore(this._opts);\n  }\n\n  ascoltatore.subscribe(topic, callback);\n};\n\nRedisAscoltatore.prototype.publish = function publish(topic, message, options, done) {\n  this._raiseIfClosed();\n\n  if (message === undefined || message === null) {\n    message = false; // so we can convert it to JSON\n  }\n\n  var payload = {\n    message: message,\n    options: options\n  };\n\n  topic = this._pubTopic(topic);\n\n  if (!topic.match(new RegExp('/$'))) {\n    topic += '/';\n  }\n  \n  this._client.publish(topic, msgpack.encode(payload), function() {\n    debug(\"new message published to \" + topic);\n    defer(done);\n  });\n};\n\nRedisAscoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  var isWildcard = this._containsWildcard(topic),\n      subTopic = this._subTopic(topic);\n\n  if (!subTopic.match(new RegExp('[/*]$'))) {\n    subTopic += '/';\n  }\n\n  this._subs_counter.remove(subTopic);\n\n  var ascoltatore = this._ascoltatores[subTopic];\n\n  if (ascoltatore) {\n    ascoltatore.unsubscribe(topic, callback);\n  }\n\n  var newDone = function() {\n    debug(\"deregistered subscriber for topic \" + topic);\n    defer(done);\n  };\n\n  if (this._subs_counter.include(subTopic)) {\n    newDone();\n    return this;\n  }\n\n  if (ascoltatore) {\n    ascoltatore.close();\n    delete this._ascoltatores[subTopic];\n  }\n\n  if (isWildcard) {\n    this._sub.punsubscribe(subTopic, newDone);\n  } else {\n    this._sub.unsubscribe(subTopic, newDone);\n  }\n\n  return this;\n};\n\nRedisAscoltatore.prototype.close = function close(done) {\n  var that = this,\n    newDone = null,\n    closes = 2;\n\n  newDone = function() {\n    debug(\"closed\");\n    defer(done);\n  };\n\n  if (this._closed) {\n    newDone();\n    return;\n  }\n\n  this._subs_counter.clear();\n  [\"_sub\", \"_client\"].forEach(function(c) {\n    if (that[c] !== undefined) {\n      that[c].on(\"end\", function() {\n        closes = closes - 1;\n        if (closes === 0) {\n          newDone();\n        }\n      });\n      that[c].quit();\n      delete that[c];\n    } else {\n      closes = closes - 1;\n    }\n  });\n\n  for (var subTopic in this._ascoltatores) {\n    this._ascoltatores[subTopic].close();\n  }\n  this._ascoltatores = {};\n\n  this.emit(\"closed\");\n};\n\nutil.aliasAscoltatore(RedisAscoltatore.prototype);\n\n/**\n * Exports the RedisAscoltatore\n *\n * @api public\n */\nmodule.exports = RedisAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/zeromq_ascoltatore.js":"\"use strict\";\n\nvar util = require(\"./util\");\nvar wrap = util.wrap;\nvar defer = util.defer;\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar debug = require(\"debug\")(\"ascoltatori:zmq\");\nvar steed = require(\"steed\")();\n\n/**\n * ZeromqAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is implemented through the `zmq` package.\n * ZeromqAscoltatore operates in a true peer-to-peer fashion, so there is\n * no central broker.\n * The two or more instances MUST be aware of each other and connect to each\n * other by the `connect` method.\n * All the instances transmit to everyone ALL messages in a broadcast fashion,\n * however loops are avoided.\n *\n * The options are:\n *  - `port`, the zmq port where messages will be published;\n *  - `controlPort`, the zmq port where control messages will be exchanged;\n *  - `remotePorts`, the remote control ports that will be connected to;\n *  - `zmq`, the zmq module (it will automatically be required if not present);\n *  - `delay`, a delay that is applied to the `ready` and `closed` events (the default is 5ms);\n *\n * @api public\n */\nfunction ZeromqAscoltatore(opts) {\n  AbstractAscoltatore.call(this);\n\n  this._opts = opts || {};\n  this._opts.delay = this._opts.delay || 5;\n  this._opts.zmq = this._opts.zmq || require(\"zmq\");\n\n  this._connectedControls = [];\n\n  this._ascoltatore = new TrieAscoltatore(opts);\n  this._startSubs();\n  this._startPub();\n  this._startControl();\n}\n\n/**\n * Inherits from AbstractAscoltatore\n *\n * @api private\n */\nZeromqAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\n/**\n * Create 0MQ connection using of the given type.\n *\n * @api private\n */\nfunction createConn(opts, type) {\n  var conn = opts.zmq.socket(type);\n  conn.identity = util.buildIdentifier();\n\n  debug(\"created \" + type + \" connection\");\n  return conn;\n}\n\n/**\n * Starts a connection to all the remote ports.\n *\n * @api private\n */\nZeromqAscoltatore.prototype._startSubs = function() {\n  var that = this;\n  if (this._sub_conns === undefined) {\n    that._sub_conns = [];\n    that._opts.remotePorts = that._opts.remotePorts || [];\n    that._opts.remotePorts.forEach(function(port) {\n      that.connect(port);\n    });\n  }\n  return this._sub_conns;\n};\n\nZeromqAscoltatore.prototype._startPub = function() {\n  var that = this;\n  if (that._pub_conn === undefined) {\n    that._pub_conn = createConn(that._opts, \"pub\");\n    debug(\"opening pub port \" + that._opts.port);\n    that._pub_conn.bind(that._opts.port, function(err) {\n      if (err) {\n        throw err;\n      }\n\n      debug(\"bound the publish connection to port \" + that._opts.port);\n\n      setTimeout(function() {\n        that._connectSub(that._opts.port, function() {\n          that.emit(\"ready\");\n        });\n      }, that._opts.delay);\n    });\n  }\n  return that._pub_conn;\n};\n\nZeromqAscoltatore.prototype._startControl = function() {\n  var that = this;\n  if (that._control_conn === undefined) {\n    that._control_conn = createConn(that._opts, \"req\");\n    debug(\"opening control port \" + that._opts.controlPort);\n    that._control_conn.bind(that._opts.controlPort, function(err) {\n      if (err) {\n        throw err;\n      }\n\n      debug(\"bound the control connection to port \" + that._opts.controlPort);\n\n      that._control_conn_interval = setInterval(function() {\n        var packet = that._sub_conns.map(function(c) {\n          return c.port;\n        }).join(\",\");\n        debug(\"sending control packet \" + packet);\n        that._control_conn.send(packet);\n      }, 250);\n\n      that._control_conn.on(\"message\", function(data) {\n        var dest = String(data);\n        debug(\"received connect response from \" + dest);\n        if (that._sub_conns.findIndex(function (conn) {\n          return conn.port === dest;\n        }) === -1) {\n          that._connectSub(dest);\n        }\n      });\n    });\n  }\n};\n\n/**\n * Connect the Ascoltatore to the remote ZeromqAscoltatore exposed\n * through the given port\n *\n * @param {String} port The control port of the remote ascoltatore\n * @param {Function} callback\n * @api public\n */\nZeromqAscoltatore.prototype.connect = function connect(port, callback) {\n  var that = this,\n    conn = null;\n\n  conn = createConn(that._opts, \"rep\");\n\n  conn.connect(port);\n\n  that._connectedControls.push(conn);\n\n  conn.on(\"message\", function(data) {\n    debug(\"received connect request from \" + data);\n    conn.send(that._opts.port);\n\n    var dests = String(data).split(\",\").filter(function(dest) {\n      var found = true;\n      that._sub_conns.forEach(function(conn) {\n        if (conn.port === dest) {\n          found = false;\n        }\n      });\n      return found;\n    }).map(function(dest) {\n      return function(cb) {\n        that._connectSub(dest, cb);\n      };\n    });\n\n    steed.parallel(dests, function() {\n      setTimeout(function() {\n        wrap(callback)();\n      }, that._opts.delay);\n    });\n  });\n};\n\n/**\n * Connect the Ascoltatore to the remote ZMQ port.\n *\n * @param {String} port The control port of the remote ascoltatore\n * @param {Function} callback\n * @api private\n */\nZeromqAscoltatore.prototype._connectSub = function(port, callback) {\n  var that = this,\n    conn = createConn(that._opts, \"sub\");\n\n  port = String(port);\n\n  debug(\"connecting to port \" + port);\n  conn.port = port;\n  conn.connect(port);\n  conn.subscribe(\"\");\n  that._sub_conns.push(conn);\n\n  conn.on(\"message\", function(data) {\n    data = data.toString();\n    var topic = null,\n      message = null;\n\n    topic = data.substr(0, data.indexOf(\" \"));\n    message = data.substr(data.indexOf(\" \") + 1);\n\n    that._ascoltatore.publish(topic, message);\n\n    debug(\"new message received for topic \" + topic);\n  });\n\n  setTimeout(function() {\n    debug(\"connected and subscribed to \" + port);\n    defer(callback);\n  }, this._opts.delay);\n\n  return this;\n};\n\n/**\n * Private stuff\n *\n * @api private\n */\nZeromqAscoltatore.prototype.subscribe = function subscribe(topic, callback, done) {\n  this._raiseIfClosed();\n  debug(\"registered new subscriber for topic \" + topic);\n  this._ascoltatore.subscribe(topic, callback, done);\n};\n\nZeromqAscoltatore.prototype.publish = function publish(topic, message, done) {\n  this._raiseIfClosed();\n\n  var toSend = topic + \" \" + message;\n\n  this._pub_conn.send(toSend);\n  debug(\"new message published to \" + topic);\n  defer(done); // simulate some steedhronicity\n};\n\nZeromqAscoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n  debug(\"deregistered subscriber for topic \" + topic);\n  this._ascoltatore.unsubscribe(topic, callback);\n  defer(done); // simulate some steedhronicity\n};\n\nZeromqAscoltatore.prototype.close = function close(done) {\n  var that = this;\n\n  if (this._closed) {\n    defer(done);\n    return;\n  }\n\n  if (that._sub_conns !== undefined) {\n    that._sub_conns.forEach(function(s) {\n      s.close();\n    });\n    delete that._sub_conns;\n  }\n\n  that._connectedControls.forEach(function(s) {\n    s.close();\n  });\n\n  if (that._pub_conn !== undefined) {\n    that._pub_conn.close();\n    delete that._pub_conn;\n  }\n\n  if (that._control_conn !== undefined && that._control_conn._zmq.state === 0) {\n    that._control_conn.close();\n    clearInterval(that._control_conn_interval);\n    delete that._control_conn_interval;\n  }\n\n  setTimeout(function() {\n    debug(\"closed\");\n    that._ascoltatore.close();\n    that.emit(\"closed\");\n    defer(done);\n  }, this._opts.delay);\n};\n\nutil.aliasAscoltatore(ZeromqAscoltatore.prototype);\n\n/**\n * Export ZeromqAscoltatore\n *\n * @api public\n */\nmodule.exports = ZeromqAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/amqp_ascoltatore.js":"\"use strict\";\n\nvar util = require(\"./util\");\nvar wrap = util.wrap;\nvar defer = util.defer;\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar steed = require(\"steed\")();\nvar SubsCounter = require(\"./subs_counter\");\nvar debug = require(\"debug\")(\"ascoltatori:amqp\");\n\n/**\n * The AMQPAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is backed by node-amqp.\n * It creates or use an exchange with the given name, using a \"topic\" topology.\n * It creates a single amqp queue for this process, in order to keep\n * the overhead low.\n *\n * It accepts these options:\n *  - `client`, which is passed through to the amq.createConnection method;\n *  - `exchange`, the exchange name;\n *  - `amqp`, the amqp module (it will automatically be required if not present);\n *\n * @param {Object} opts The options for creating this ascoltatore.\n * @api public\n */\n\nfunction AMQPAscoltatore(opts) {\n  AbstractAscoltatore.call(this, opts, {\n    separator: '.',\n    wildcardOne: '*',\n    wildcardSome: '#'\n  });\n\n  this._opts = opts || {};\n  this._opts.amqp = this._opts.amqp || require(\"amqp\");\n  this._ascoltatore = new TrieAscoltatore(opts);\n\n  this._subs_counter = new SubsCounter();\n  this._startConn();\n}\n\n/**\n * The client connection decends from AbstractAscoltatore.\n *\n * @api private\n */\nAMQPAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\n/**\n * Starts a new connection to an AMQP server.\n * Do nothing if it is already started.\n *\n * @api private\n */\nAMQPAscoltatore.prototype._startConn = function() {\n  var conn = null,\n    that = this;\n\n  if (this._client_conn === undefined) {\n\n    conn = this._opts.amqp.createConnection(this._opts.client);\n    this._client_conn = conn;\n\n    conn.on(\"error\", function(error) {\n      if (typeof error === 'string') {\n        error = (new Error(error));\n      }\n\n      that.emit(\"error\", error);\n    });\n\n    debug(\"connecting to \" + this._opts.client);\n\n    steed.series([\n\n      function(callback) {\n        that._client_conn.once(\"ready\", wrap(callback));\n      },\n\n      function(callback) {\n        debug(\"connected\");\n        that._exchange = conn.exchange(that._opts.exchange, {\n          type: \"topic\",\n          confirm: true\n        });\n        that._exchange.once(\"open\", wrap(callback));\n      },\n\n      function(callback) {\n        debug(\"created exchange \" + that._opts.exchange);\n        that._queue = conn.queue(util.buildIdentifier(), wrap(callback));\n        that._queue.setMaxListeners(0); // avoid problems with listeners\n      },\n\n      function(callback) {\n        that._queue.subscribe({\n          ack: true,\n          prefetchCount: 42\n        }, function(message, headers, deliveryInfo) {\n          that._queue.shift();\n\n          var topic = that._recvTopic(deliveryInfo.routingKey);\n          \n          debug(\"new message received from queue on topic \" + topic);\n\n          that._ascoltatore.publish(topic, message.data.toString());\n        });\n        that._queue.once(\"basicConsumeOk\", function() {\n          defer(callback);\n        });\n      },\n\n      function(callback) {\n        debug(\"subscribed to queue\");\n        that.emit(\"ready\");\n        callback();\n      }\n    ]);\n  }\n  return this._client_conn;\n};\n\nAMQPAscoltatore.prototype.subscribe = function subscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  this._ascoltatore.subscribe(topic, callback);\n\n  if (!this._subs_counter.include(topic)) {\n\n    debug(\"binding queue to topic \" + topic);\n\n    this._queue.once(\"queueBindOk\", function() {\n      // trick against node-amqp not working\n      // as advertised\n      setTimeout(function() {\n        debug(\"queue bound to topic \" + topic);\n        defer(done);\n      }, 5);\n    });\n\n    this._queue.bind(this._exchange, this._subTopic(topic));\n  } else {\n    defer(done);\n  }\n\n  this._subs_counter.add(topic);\n\n  debug(\"registered new subscriber for topic \" + topic);\n};\n\nAMQPAscoltatore.prototype.publish = function publish(topic, message, done) {\n  this._raiseIfClosed();\n\n  debug(\"new message published to \" + topic);\n\n  this._exchange.publish(this._pubTopic(topic), String(message));\n  defer(done);\n};\n\nAMQPAscoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n  this._subs_counter.remove(topic);\n\n  debug(\"deregistered subscriber for topic \" + topic);\n\n  this._ascoltatore.unsubscribe(topic, callback);\n\n  if (!this._subs_counter.include(topic)) {\n    this._queue.once(\"queueUnbindOk\", function() {\n      debug(\"queue unbound to topic \" + topic);\n      defer(done);\n    });\n\n    this._queue.unbind(this._exchange, this._subTopic(topic));\n  } else {\n    defer(done);\n  }\n\n  return this;\n};\n\nAMQPAscoltatore.prototype.close = function close(done) {\n  var that = this;\n\n  if (this._closed) {\n    wrap(done)();\n    return;\n  }\n\n  if (this._closing) {\n    this.on(\"closed\", done);\n    return;\n  }\n\n  this._closing = true;\n\n  if (this._client_conn !== undefined) {\n    var doClose = function () {\n      if (that._closed) {\n        debug(\"closing twice, one was an error\");\n        return;\n      }\n\n      debug(\"closed\");\n      defer(done);\n      that.emit(\"closed\");\n    };\n\n    this._client_conn.on(\"close\", doClose);\n\n    this._queue.destroy();\n    this._client_conn.end();\n    this._client_conn.removeAllListeners(\"error\");\n    this._client_conn.on(\"error\", doClose);\n\n    delete this._client_conn;\n    delete this._exchange;\n    delete this._queue;\n  }\n};\n\nutil.aliasAscoltatore(AMQPAscoltatore.prototype);\n\n/**\n * Exports the AMQPAscoltatore\n *\n * @api public\n */\nmodule.exports = AMQPAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/amqplib_ascoltatore.js":"\"use strict\";\n\nvar util = require(\"./util\");\nvar wrap = util.wrap;\nvar defer = util.defer;\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar steed = require(\"steed\")();\nvar SubsCounter = require(\"./subs_counter\");\nvar debug = require(\"debug\")(\"ascoltatori:amqplib\");\n\n/**\n * The AMQPAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is backed by node-amqp.\n * It creates or use an exchange with the given name, using a \"topic\" topology.\n * It creates a single amqp queue for this process, in order to keep\n * the overhead low.\n *\n * It accepts these options:\n *  - `client`, which is passed through to the amq.createConnection method;\n *  - `exchange`, the exchange name;\n *  - `amqp`, the amqp module (it will automatically be required if not present);\n *\n * @param {Object} opts The options for creating this ascoltatore.\n * @api public\n */\n\nfunction AMQPLibAscoltatore(opts) {\n  AbstractAscoltatore.call(this, opts, {\n    separator: '.',\n    wildcardOne: '*',\n    wildcardSome: '#'\n  });\n\n  this._opts = opts || {};\n  this._opts.amqp = this._opts.amqp || require(\"amqplib/callback_api\");\n  this._ascoltatore = new TrieAscoltatore(opts);\n\n  this._subs_counter = new SubsCounter();\n  this._startConn();\n}\n\n/**\n * The client connection decends from AbstractAscoltatore.\n *\n * @api private\n */\nAMQPLibAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\n/**\n * Starts a new connection to an AMQP server.\n * Do nothing if it is already started.\n *\n * @api private\n */\nAMQPLibAscoltatore.prototype._startConn = function () {\n  var conn = null,\n    channel = null,\n    that = this;\n\n  if (this._client_conn === undefined) {\n\n    var url = this._opts.url || 'amqp://127.0.0.1:5672';\n\n    var socketOptions = this._opts.socketOptions || {};\n\n    debug(\"connecting to \" + this._opts.url);\n\n    steed.series([\n      function (callback) {\n        that._opts.amqp.connect(url, socketOptions, function (err, conn) {\n          that._client_conn = conn;\n          conn.on(\"error\", function (error) {\n            if (typeof error === 'string') {\n              error = (new Error(error));\n            }\n\n            that.emit(\"error\", error);\n          });\n          callback();\n        });\n      },\n\n      function (callback) {\n        debug('connected');\n        that._client_conn.createChannel(function(err, channel){\n          that._channel = channel;\n          that._channel.prefetch(42); // magic number?\n          callback();\n        });\n      },\n\n      function(callback){\n        debug('channel created');\n        that._queue = util.buildIdentifier();\n        that._channel.assertQueue(that._queue, {durable: false}, wrap(callback));\n      },\n\n      function (callback){\n        debug('queue created');\n        that._channel.assertExchange(that._opts.exchange, 'topic', {}, wrap(callback));\n      },\n\n      function (callback){\n        debug('exchange existed');\n        that._channel.consume(that._queue, function(msg){\n          that._channel.ack(msg);\n          var topic = that._recvTopic(msg.fields.routingKey);\n          debug(\"new message received from queue on topic \" + topic);\n          that._ascoltatore.publish(topic, msg.content.toString());\n        }, null, wrap(callback));\n      },\n\n      function (callback) {\n        debug(\"subscribed to queue\");\n        that.emit(\"ready\");\n        callback();\n      }\n    ]);\n  }\n  return this._client_conn;\n};\n\nAMQPLibAscoltatore.prototype.subscribe = function subscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  this._ascoltatore.subscribe(topic, callback);\n\n  if (!this._subs_counter.include(topic)) {\n    debug(\"binding queue to topic \" + topic);\n\n    this._channel.bindQueue(this._queue, this._opts.exchange, this._subTopic(topic), {}, function(err, ok){\n        debug(\"queue bound to topic \" + topic);\n        defer(done);\n    });\n  } else {\n    defer(done);\n  }\n\n  this._subs_counter.add(topic);\n\n  debug(\"registered new subscriber for topic \" + topic);\n};\n\nAMQPLibAscoltatore.prototype.publish = function publish(topic, message, done) {\n  this._raiseIfClosed();\n\n  debug(\"new message published to \" + topic);\n\n  this._channel.publish(this._opts.exchange, this._pubTopic(topic), new Buffer(String(message)));\n  defer(done);\n};\n\nAMQPLibAscoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n  this._subs_counter.remove(topic);\n\n  debug(\"deregistered subscriber for topic \" + topic);\n\n  this._ascoltatore.unsubscribe(topic, callback);\n\n  if (!this._subs_counter.include(topic)) {\n    this._channel.unbindQueue(this._queue, this._opts.exchange, this._subTopic(topic), {}, function(err, ok) {\n      debug(\"queue unbound to topic \" + topic);\n      defer(done);\n    });\n  } else {\n    defer(done);\n  }\n\n  return this;\n};\n\nAMQPLibAscoltatore.prototype.close = function close(done) {\n  var that = this;\n\n  if (this._closed) {\n    wrap(done)();\n    return;\n  }\n\n  if (this._closing) {\n    this.on(\"closed\", done);\n    return;\n  }\n\n  this._closing = true;\n\n  if (this._client_conn !== undefined) {\n    var doClose = function () {\n      if (that._closed) {\n        debug(\"closing twice, one was an error\");\n        return;\n      }\n\n      debug(\"closed\");\n      defer(done);\n      that.emit(\"closed\");\n    };\n\n    this._client_conn.on(\"close\", doClose);\n    this._channel.deleteQueue(this._queue);\n    this._channel.close();\n\n    this._client_conn.close();\n    this._client_conn.removeAllListeners(\"error\");\n    this._client_conn.on(\"error\", doClose);\n\n    delete this._client_conn;\n    delete this._channel;\n    delete this._queue;\n  }\n};\n\nutil.aliasAscoltatore(AMQPLibAscoltatore.prototype);\n\n/**\n * Exports the AMQPAscoltatore\n *\n * @api public\n */\nmodule.exports = AMQPLibAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/mqtt_ascoltatore.js":"\"use strict\";\n\nvar util = require(\"./util\");\nvar wrap = util.wrap;\nvar defer = util.defer;\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar debug = require(\"debug\")(\"ascoltatori:mqtt\");\nvar SubsCounter = require(\"./subs_counter\");\nvar steed = require(\"steed\")();\n\n/**\n * MQTTAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is implemented through the `mqtt` package and it could be\n * backed up by any MQTT broker out there.\n *\n * The options are:\n *  - `url`: the URL to connect to, as defined in https://www.npmjs.com/package/mqtt#connect\n *  -  ... all the options defined in https://www.npmjs.com/package/mqtt#connect\n *\n * @api public\n * @param {Object} opts The options object\n */\nfunction MQTTAscoltatore(opts) {\n  AbstractAscoltatore.call(this, opts, {\n    separator: '/',\n    wildcardOne: '+',\n    wildcardSome: '#'\n  });\n\n  this._opts = opts || {};\n  this._opts.keepalive = this._opts.keepalive || 3000;\n  this._opts.mqtt = this._opts.mqtt || require(\"mqtt\");\n\n  this._subs_counter = new SubsCounter();\n\n  this._ascoltatore = new TrieAscoltatore(opts);\n  this._startConn();\n}\n\n/**\n * MQTTAscoltatore inherits from AbstractAscoltatore\n *\n * @api private\n */\nMQTTAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\n/**\n * Starts a new connection to an MQTT server.\n * Do nothing if it is already started.\n *\n * @api private\n */\nMQTTAscoltatore.prototype._startConn = function() {\n  var that = this;\n  var url = that._opts.url;\n  var settings = null;\n\n  if (this._client === undefined) {\n    debug(\"connecting..\");\n    if (url) {\n      this._client = this._opts.mqtt.connect(url, that._opts);\n    } else {\n      this._client = this._opts.mqtt.connect(that._opts);\n    }\n\n    this._client.setMaxListeners(0);\n    this._client.on(\"connect\", function() {\n      debug(\"connected\");\n      that.reconnectTopics(function(){\n        that.emit(\"ready\");\n      });\n    });\n    this._client.on(\"message\", function(topic, payload, packet) {\n      debug(\"received new packet on topic \" + topic);\n      // we need to skip out this callback, so we do not\n      // break the client when an exception occurs\n      defer(function() {\n        that._ascoltatore.publish(that._recvTopic(topic), payload, packet);\n      });\n    });\n    this._client.on('error', function(e) {\n      debug(\"error in the client\");\n\n      delete that._client;\n      that.emit(\"error\", e);\n    });\n  }\n  return this._client;\n};\n\nMQTTAscoltatore.prototype.reconnectTopics = function reconnectTopics(cb) {\n  var that = this;\n\n  var subscribedTopics = that._subs_counter.keys();\n\n  var opts = {\n    qos: 1\n  };\n\n  steed.each(subscribedTopics, function(topic, callback) {\n    that._client.subscribe(that._subTopic(topic), opts, function() {\n      debug(\"re-registered subscriber for topic \" + topic);\n      callback();\n    });\n  }, function(){\n    cb();\n  });\n\n};\n\nMQTTAscoltatore.prototype.subscribe = function subscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  if (!this._subs_counter.include(topic)) {\n    debug(\"registering new subscriber for topic \" + topic);\n\n    var opts = {\n      qos: 1\n    };\n    this._client.subscribe(this._subTopic(topic), opts, function() {\n      debug(\"registered new subscriber for topic \" + topic);\n      defer(done);\n    });\n  } else {\n    defer(done);\n  }\n\n  this._subs_counter.add(topic);\n  this._ascoltatore.subscribe(topic, callback);\n};\n\nMQTTAscoltatore.prototype.publish = function publish(topic, message, options, done) {\n  this._raiseIfClosed();\n\n  this._client.publish(this._pubTopic(topic), message, {\n    qos: (options && (options.qos !== undefined)) ? options.qos : 1,\n    retain: (options && (options.retain !== undefined)) ? options.retain : false\n  }, function() {\n    debug(\"new message published to \" + topic);\n    wrap(done)();\n  });\n};\n\nMQTTAscoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n\n  var newDone = null;\n\n  newDone = function() {\n    debug(\"deregistered subscriber for topic \" + topic);\n    defer(done);\n  };\n\n  this._ascoltatore.unsubscribe(topic, callback);\n  this._subs_counter.remove(topic);\n\n  if (this._subs_counter.include(topic)) {\n    newDone();\n    return;\n  }\n\n  debug(\"deregistering subscriber for topic \" + topic);\n  this._client.unsubscribe(this._subTopic(topic), newDone);\n};\n\nMQTTAscoltatore.prototype.close = function close(done) {\n  var that = this;\n  debug(\"closing\");\n  if (!this._closed) {\n    this._subs_counter.clear();\n    this._client.once(\"close\", function() {\n      debug(\"closed\");\n      that._ascoltatore.close();\n      delete that._client;\n      that.emit(\"closed\");\n      defer(done);\n    });\n    this._client.end();\n  } else {\n    wrap(done)();\n  }\n};\n\nutil.aliasAscoltatore(MQTTAscoltatore.prototype);\n\n/**\n * Exports the MQTTAscoltatore\n *\n * @api public\n */\nmodule.exports = MQTTAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/prefix_acoltatore.js":"\"use strict\";\n\nvar DecoratorAscoltatore = require(\"./decorator_ascoltatore\");\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar util = require(\"./util\");\nvar debug = require(\"debug\")(\"ascoltatori:prefix\");\n\n/**\n * An Ascoltatore decorator to publish messages on a\n * parent Ascoltatore with a prefix.\n *\n * @param {String} prefix\n * @param {AbstractAscoltatore} ascoltatore\n * @api public\n */\nfunction PrefixAscoltatore(prefix, ascoltatore) {\n  DecoratorAscoltatore.call(this, ascoltatore || new TrieAscoltatore());\n\n  this._prefix = prefix;\n  this._separator = this._ascoltatore._separator;\n}\n\n/**\n * See AbstractAscoltatore for the public API definitions.\n *\n * @api private\n */\nPrefixAscoltatore.prototype = Object.create(DecoratorAscoltatore.prototype);\n\nPrefixAscoltatore.prototype.wrapCallback = function(callback, next) {\n  var that = this;\n  if (!callback._prefix_ascoltatore_wrapper) {\n    callback._prefix_ascoltatore_wrapper = function(t, payload, options) {\n      callback(that._parentToLocal(t), payload, options);\n    };\n  }\n  next(null, callback._prefix_ascoltatore_wrapper);\n};\n\nPrefixAscoltatore.prototype._localToParent = function(topic) {\n  var newTopic = this._prefix;\n  newTopic += (topic.indexOf(this._separator) !== 0) ? this._separator : '';\n  newTopic += topic;\n  debug(\"rewriting local topic \" + topic + \" into \" + newTopic);\n  return newTopic;\n};\n\nPrefixAscoltatore.prototype.wrapTopic = function(topic, next) {\n  next(null, this._localToParent(topic));\n};\n\nPrefixAscoltatore.prototype._parentToLocal = function(topic) {\n  var newTopic;\n  if (topic.lastIndexOf(this._prefix + this._separator, 0) === 0) {\n    newTopic = topic.substr(this._prefix.length + 1);\n  } else {\n    newTopic = topic;\n  }\n  debug(\"rewriting remote topic \" + topic + \" into \" + newTopic);\n  return newTopic;\n};\n\n/**\n * Exports the PrefixAscoltatore.\n *\n * @api public\n */\nmodule.exports = PrefixAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/decorator_ascoltatore.js":"\"use strict\";\n\nvar steed = require(\"steed\")();\nvar AbstractAscoltatore = require(\"./abstract_ascoltatore\");\n\n/**\n * Decorates totally another ascoltatore, doing nothing\n * but forwarding the method calls, this should\n * be a reference implementation for other decorators.\n *\n * @param {Object} decorated The decorated Ascoltatore\n * @api public\n */\nfunction DecoratorAscoltatore(decorated) {\n  this._ascoltatore = decorated;\n  AbstractAscoltatore.prototype._setPublish.call(this);\n}\n\n/**\n * Translate the topic name in another\n *\n * @param String topic The topic name\n * @param Function next The function that will be called\n * @api public\n */\nDecoratorAscoltatore.prototype.wrapTopic = function(topic, next) {\n  next(null, topic);\n};\n\n/**\n * Translate the callback in another\n *\n * @param Function callback The callback to be translated\n * @param Function next The function that will be called\n * @api public\n */\nDecoratorAscoltatore.prototype.wrapCallback = function(callback, next) {\n  next(null, callback);\n};\n\n/**\n * Translate the payload in another\n *\n * @param String payload The payload\n * @param Function next The function that will be called\n * @api public\n */\nDecoratorAscoltatore.prototype.wrapPayload = function(payload, next) {\n  next(null, payload);\n};\n\n/**\n * Forwarding methods\n *\n * @api private\n */\n\nDecoratorAscoltatore.prototype.on = function(event, callback) {\n  this._ascoltatore.on(event, callback);\n  return this;\n};\n\nDecoratorAscoltatore.prototype.once = function(event, callback) {\n  this._ascoltatore.once(event, callback);\n  return this;\n};\n\nDecoratorAscoltatore.prototype.removeListener = function(event, callback) {\n  this._ascoltatore.removeListener(event, callback);\n  return this;\n};\n\nDecoratorAscoltatore.prototype.subscribe = function(topic, callback, done) {\n  var that = this;\n  steed.waterfall([\n\n    function(cb) {\n      that.wrapTopic(topic, cb);\n    },\n\n    function(newTopic, cb) {\n      that.wrapCallback(callback, function(err, newCallback) {\n        cb(err, newTopic, newCallback);\n      });\n    },\n\n    function(newTopic, newCallback, cb) {\n      that._ascoltatore.subscribe(newTopic, newCallback, cb);\n    }\n  ], done);\n};\n\nDecoratorAscoltatore.prototype.unsubscribe = function(topic, callback, done) {\n  var that = this;\n  steed.waterfall([\n\n    function(cb) {\n      that.wrapTopic(topic, cb);\n    },\n\n    function(newTopic, cb) {\n      that.wrapCallback(callback, function(err, newCallback) {\n        cb(err, newTopic, newCallback);\n      });\n    },\n\n    function(newTopic, newCallback, cb) {\n      that._ascoltatore.unsubscribe(newTopic, newCallback, cb);\n    }\n  ], done);\n};\n\nDecoratorAscoltatore.prototype.publish = function(topic, payload, options, done) {\n  var that = this;\n  steed.waterfall([\n\n    function(cb) {\n      that.wrapTopic(topic, cb);\n    },\n\n    function(newTopic, cb) {\n      that.wrapPayload(payload, function(err, newPayload) {\n        cb(err, newTopic, newPayload);\n      });\n    },\n\n    function(newTopic, newPayload, cb) {\n      that._ascoltatore.publish(newTopic, newPayload, options, cb);\n    }\n  ], done);\n};\n\nDecoratorAscoltatore.prototype.close = function(done) {\n  this._ascoltatore.close(done);\n};\n\nDecoratorAscoltatore.prototype.unsub = function(topic, callback, done) {\n  this.unsubscribe(topic, callback, done);\n};\n\nDecoratorAscoltatore.prototype.sub = function(topic, callback, done) {\n  this.subscribe(topic, callback, done);\n};\n\nDecoratorAscoltatore.prototype.pub = function(topic, payload, options, done) {\n  this.publish(topic, payload, options, done);\n};\n\nmodule.exports = DecoratorAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/mongo_ascoltatore.js":"\"use strict\";\n\nvar util = require(\"./util\");\nvar wrap = util.wrap;\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar SubsCounter = require(\"./subs_counter\");\nvar debug = require(\"debug\")(\"ascoltatori:mongodb\");\nvar mongo = require('mongodb');\nvar MongoClient = require('mongodb').MongoClient;\nvar ObjectID = require('mongodb').ObjectID;\nvar steed = require(\"steed\");\n\n/**\n * MongoAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is implemented through the `mongoskin` package.\n *\n * The options are:\n * `url`: the mongodb url (default: 'mongodb://localhost:27017/ascoltatori?auto_reconnect=true')\n * `pubsubCollection`: where to store the messages on mongodb (default: pubsub)\n * `mongo`: settings for the mongodb connection\n *\n * @api public\n * @param {Object} opts The options object\n */\nvar MongoAscoltatore = function(opts) {\n  AbstractAscoltatore.call(this);\n\n  if (typeof opts.db === 'string' || opts.uri) {\n    // old options\n    opts.uri = opts.uri || 'mongodb://127.0.0.1/';\n    opts.db = opts.db || 'ascoltatori';\n    opts.url = opts.uri + opts.db + '?auto_reconnect=true';\n    delete opts.db;\n  }\n\n  this._opts = opts || {};\n  this.url = this._opts.url || 'mongodb://127.0.0.1/ascoltatori?auto_reconnect=true';\n  this._pubsubCollection = opts.pubsubCollection || 'pubsub';\n  this._maxRetry = opts.maxRetry || 5;\n  this.mongoOpts = this._opts.mongo || {};\n\n  this._ascoltatore = new TrieAscoltatore(opts);\n\n  this.channels = {};\n  this._closed = false;\n\n  this._handlingCursorFailure = false;\n  this._lastSuccessfulHandling = new ObjectID();\n\n  this.wait = this._opts.wait || 100;\n\n  this.connectionParams = {\n    capped: true,\n    size: this._opts.size || 10 * 1024 * 1024, // 10 MB\n    max: this._opts.max || 10000 // documents\n  };\n\n  var that = this;\n\n  var setupDB = function(err, db) {\n    if (err) {\n      that.emit('error', err);\n      return;\n    }\n\n    that.db = db;\n\n    // creating the capped collection where we can exchange messages\n    that.db.createCollection(that._pubsubCollection, that.connectionParams, function(err, collection) {\n      if (err) {\n        that.emit('error', err);\n      } else  {\n        that.collection = collection;\n\n        debug('ready');\n\n        // create a new object id. We will get all the events from now on\n        that._poll(new ObjectID());\n\n        that.emit('ready');\n      }\n    });\n  };\n\n  if (opts.db) {\n    setupDB(null, opts.db);\n  } else {\n    MongoClient.connect(this.url, this.mongoOpts, setupDB);\n  }\n};\n\n/**\n * Inheriting\n *\n * @api private\n */\nMongoAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\nMongoAscoltatore.prototype.publish = function(topic, message, options, done) {\n  this._raiseIfClosed();\n  message = message || \"\";\n  done = done || function() {};\n\n  var messageObj = {\n    value: message,\n    topic: topic,\n    options: options\n  };\n\n  debug('publishing message', messageObj);\n\n  this.collection.insert(messageObj, { w: 1 }, done);\n};\n\n/**\n *\n * @return {Boolean} true when the user is not connected with mongodb\n * @private\n */\nMongoAscoltatore.prototype._disconnected = function() {\n  return this.db.db.state === 'disconnected';\n};\n\n/**\n * Used to avoid to continue to go on if an error occurs\n *\n * @param die if true, avoid to keep going and just report the error\n * @param callback real callback to call\n * @return {Function} simply exit\n * @private\n */\nMongoAscoltatore.prototype._handle = function(die, callback) {\n\n  debug('handle');\n\n  var that = this;\n\n  return function() {\n    if (that._disconnected()) {\n      debug('disconnected');\n      return;\n    }\n\n    var args = [].slice.call(arguments),\n      err = args.shift();\n\n    if (err && !that._closed) {\n      that._handleCursorClosed(that._lastSuccessfulHandling);\n      return;\n    }\n\n    if (err && die) {\n      debug('ERROR: ' + err);\n      return;\n    }\n\n    debug('handle -> calling the callback');\n    callback.apply(that, args);\n  };\n};\n\nMongoAscoltatore.prototype.subscribe = function(topic, callback, done) {\n  this._raiseIfClosed();\n\n  debug('subscribe');\n  this._ascoltatore.subscribe(topic, callback, done);\n};\n\n/**\n * In case of error, wait for the db to recover (auto_reconnect).\n * And repoll the tailable collection.\n * @param latest\n * @private\n */\nMongoAscoltatore.prototype._handleCursorClosed = function (latest) {\n  debug('handleCursorClosed');\n  if (this._closed !== false) {\n    // Handle cursor closed. But we're closed actually. Do nothing\n    return;\n  }\n  if (this._handlingCursorFailure !== false) {\n    // Already handling this failure\n    return;\n  }\n  var that = this;\n\n  this._handlingCursorFailure = true;\n\n  // Kind of hacky solution, I would prefer catch some mongo events\n  // but unfortunately...\n  var retry = 0;\n  var reconnect = function () {\n    debug('handleCursorClosed -> Wait for the database to be connected...');\n    that.db.db(that.db.databaseName).stats({}, function (err, stats) {\n      var success = true;\n      if (err) {\n        debug('handleCursorClosed -> Stats failed: ' + err);\n        success = false;\n      } else if (!stats.ok) {\n        debug('handleCursorClosed -> Stats says that DB is not ok : ' + stats);\n        success = false;\n      }\n      if (success === false) {\n        retry++;\n        debug('handleCursorClosed -> Handle cursor failed: retry #' + retry);\n        if (retry < that._maxRetry) {\n          setTimeout(reconnect, 5000);\n        } else {\n          that.emit('error', new Error('Mongo is out of order'));\n          that._handlingCursorFailure = false;\n        }\n      } else {\n        debug(\"handleCursorClosed ->  We're now ready. Poll.\");\n        that._checkCappedAndPoll(latest);\n      }\n    });\n  };\n\n  reconnect();\n};\n\n/**\n * Check if the pubsub collection is capped. Avoiding to enter in a\n * error event loop.\n * @param latest\n * @private\n */\nMongoAscoltatore.prototype._checkCappedAndPoll = function(latest) {\n  debug('checkCappedAndPoll');\n  var that = this;\n  this.collection.isCapped(function(err, isCapped) {\n    if (err) {\n      debug('checkCappedAndPoll -> Cannot stat isCapped. Give up');\n      that.emit('error', new Error('Cannot stat if collection is capped or not'));\n      that._handlingCursorFailure = false;\n      return;\n    }\n    if (!isCapped) {\n      debug('checkCappedAndPoll -> Collection is not capped. Give up');\n      that.emit('error', new Error('Cannot recover. Collection is not capped.'));\n      that._handlingCursorFailure = false;\n    } else {\n      debug('checkCappedAndPoll -> Capped Ok. Poll.');\n      that._poll(latest);\n      that._handlingCursorFailure = false;\n    }\n  });\n};\n\n/**\n * function to poll from mongodb for the infos\n * @param latest starting id to look at\n * @private\n */\nMongoAscoltatore.prototype._poll = function(latest) {\n  debug('poll');\n\n  var options = {\n    tailable: true,\n    awaitdata: true,\n    numberOfRetries: -1\n  };\n\n  this._cursor = this.collection.find({ _id: { $gt: latest } }, options);\n\n  // we have created only the cursor, now take a look at the messages arrived until now\n  this._more(latest);\n};\n\n/**\n *\n * @param {ObjectID} latest as above, first id to use as reference\n * @private\n */\nMongoAscoltatore.prototype._more = function(latest) {\n  var that = this;\n\n  debug('more');\n\n  that._cursor.each(that._handle(true, function(doc) {\n\n    var value;\n\n    if (!doc) {\n      debug('setting the subscriber polling');\n      that._pollTimeout = setTimeout(function() {\n        that._poll(latest);\n      }, that.wait);\n      return;\n    }\n\n    debug('calling the subscriber callback');\n\n    latest = latest > doc._id ? latest: doc._id;\n    that._lastSuccessfulHandling = latest;\n\n    if (!that._closed) {\n      if (doc.value && doc.value.buffer) {\n        value = doc.value.buffer;\n      } else {\n        value = doc.value;\n      }\n\n      that._ascoltatore.publish(doc.topic, value, doc.options);\n    }\n  }));\n};\n\nMongoAscoltatore.prototype.unsubscribe = function() {\n  this._raiseIfClosed();\n  this._ascoltatore.unsubscribe.apply(this._ascoltatore, arguments);\n};\n\nMongoAscoltatore.prototype.unsub = MongoAscoltatore.prototype.unsubscribe;\n\nMongoAscoltatore.prototype.close = function close(done) {\n  var that = this;\n  var closeEmbedded = function() {\n    that._ascoltatore.close(function() {\n      that.emit(\"closed\");\n      if (done) {\n        done();\n      }\n    });\n  };\n\n  if (this._pollTimeout) {\n    clearTimeout(this._pollTimeout);\n  }\n\n  that._closed = true;\n\n  steed.series([\n    function(cb) {\n      if (that._cursor) {\n        that._cursor.close(cb);\n        delete that._cursor;\n      } else {\n        cb();\n      }\n    },\n    function(cb) {\n      that.db.close(cb);\n    }\n  ], closeEmbedded);\n};\n\nutil.aliasAscoltatore(MongoAscoltatore.prototype);\n\n/**\n * Exports the MongoAscoltatore\n *\n * @api public\n */\nmodule.exports = MongoAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/json_ascoltatore.js":"\"use strict\";\n\nvar DecoratorAscoltatore = require(\"./decorator_ascoltatore\");\nvar util = require(\"./util\");\nvar debug = require(\"debug\")(\"ascoltatori:json\");\n\n/**\n * An Ascoltatore decorator to publish messages on a\n * parent Ascoltatore with a prefix.\n *\n * @param {AbstractAscoltatore} ascoltatore\n * @api public\n */\nfunction JSONAscoltatore(ascoltatore) {\n  DecoratorAscoltatore.call(this, ascoltatore);\n}\n\n/**\n * See AbstractAscoltatore for the public API definitions.\n *\n * @api private\n */\nJSONAscoltatore.prototype = Object.create(DecoratorAscoltatore.prototype);\n\nJSONAscoltatore.prototype.wrapCallback = function(callback, next) {\n  var that = this;\n  if (!callback._json_ascoltatore_wrapper) {\n    callback._json_ascoltatore_wrapper = function(t, payload, options) {\n      debug(\"converting from JSON\");\n      var errored = false;\n\n      try {\n        payload = JSON.parse(payload);\n      } catch (e) {\n        errored = true;\n        debug(\"The payload is not a valid JSON\", e);\n      }\n\n      if (!errored) {\n        callback(t, payload, options);\n      }\n    };\n  }\n  next(null, callback._json_ascoltatore_wrapper);\n};\n\nJSONAscoltatore.prototype.wrapPayload = function(payload, next) {\n\n  if (payload === undefined || payload === null) {\n    payload = false; // so we can convert it to JSON\n  }\n\n  debug(\"converting to JSON\");\n  next(null, JSON.stringify(payload));\n};\n\n/**\n * Exports the JSONAscoltatore.\n *\n * @api public\n */\nmodule.exports = JSONAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/filesystem_ascoltatore.js":"\"use strict\";\n\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar crypto = require('crypto');\nvar util = require('./util');\nvar debug = require('debug')('ascoltatori:filesystem');\n\n/**\n * FileSystemAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is implemented using the `qlobber-fsq` module and writes messages to disk. *\n * See the [`qlobber-fsq` documentation](https://github.com/davedoesdev/qlobber-fsq) for available options.\n */\nfunction FileSystemAscoltatore(opts)\n{\n  AbstractAscoltatore.call(this, opts, {\n    separator: '.'\n  });\n\n  opts = opts || {};\n\n  var QlobberFSQ = (opts.qlobber_fsq || require('qlobber-fsq')).QlobberFSQ;\n\n  opts.separator = this._nativeSettings.separator;\n  opts.wildcard_one = this._wildcardOne;\n  opts.wildcard_some = this._wildcardSome;\n  opts.dedup = false;\n\n  this._dehnd = '__filesystem_ascoltatore' + crypto.randomBytes(16).toString('base64');\n  this._fsq = new QlobberFSQ(opts);\n\n  var ths = this;\n\n  this._fsq.on('start', function () {\n    ths.emit('ready');\n  });\n}\n\n/**\n * See AbstractAscoltatore for the public API definitions.\n *\n * @api private\n */\n\nFileSystemAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\nFileSystemAscoltatore.prototype.subscribe = function (topic, callback, done)\n{\n  var ths = this;\n\n  function cb(data, info, cb2)\n  {\n    data = JSON.parse(data);\n    callback(ths._recvTopic(info.topic), data.message, data.options);\n    cb2();\n  }\n\n  var f = cb;\n\n  callback[this._dehnd] = callback[this._dehnd] || f;\n\n  this._fsq.subscribe(this._subTopic(topic),\n                      callback[this._dehnd],\n                      done);\n};\n\nFileSystemAscoltatore.prototype.unsubscribe = function (topic, callback, done)\n{\n  this._fsq.unsubscribe(this._subTopic(topic),\n                        callback[this._dehnd] || callback,\n                        done);\n};\n\nFileSystemAscoltatore.prototype.publish = function (topic, message, options, done)\n{\n  this._fsq.publish(this._pubTopic(topic), JSON.stringify({\n    message: message,\n    options: options\n  }), done);\n};\n\nFileSystemAscoltatore.prototype.close = function (done)\n{\n  this._fsq.stop_watching(done);\n};\n\nutil.aliasAscoltatore(FileSystemAscoltatore.prototype);\n\n/**\n * Exports the FileSystemAscoltatore.\n *\n * @api public\n */\nmodule.exports = FileSystemAscoltatore;\n\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/kafka_ascoltatore.js":"\"use strict\";\n\nvar util = require(\"./util\");\nvar defer = util.defer;\nvar TrieAscoltatore = require(\"./trie_ascoltatore\");\nvar AbstractAscoltatore = require('./abstract_ascoltatore');\nvar debug = require(\"debug\")(\"ascoltatori:kafka\");\nvar Qlobber = require('qlobber').Qlobber;\nvar SubsCounter = require(\"./subs_counter\");\n\n/**\n * KafkaAscoltatore is a class that inherits from AbstractAscoltatore.\n * It is implemented through the `kafka-node` package and it could be\n * backed up by kafka 0.8 and above.\n *\n * The options are:\n *  - connectionString: Zookeeper connection string, default localhost:2181/\n *  - clientId: This is a user-supplied identifier for the client application, default kafka-node-client\n *  - zkOptions: Object, Zookeeper options, see node-zookeeper-client\n *  - noAckBatchOptions: Object, when requireAcks is disabled on Producer side we can define the batch properties, 'noAckBatchSize' in bytes and 'noAckBatchAge' in milliseconds. The default value is { noAckBatchSize: null, noAckBatchAge: null } and it acts as if there was no batch\n *  - groupId: Consumer group id, defaults to kafka-node-group\n *  - encodings: map of topic:encoding where encoding is not the defaultEncoding\n *  - defaultEncoding: default value is utf8\n *\n * @api public\n * @param {Object} opts The options object\n */\nfunction KafkaAscoltatore(opts) {\n  AbstractAscoltatore.call(this, opts, {\n    separator: '_',\n    wildcardOne: '*',\n    wildcardSome: '#'\n  });\n  this._default_opts = {connectionString: \"localhost:2181/\", clientId: \"kafka-node-client\", groupId: \"kafka-node-group\"};\n  this._opts = opts || this._default_opts;\n  this._opts.keepalive = this._opts.keepalive || 3000;\n  this._opts.kafka = this._opts.kafka || require(\"kafka-node\");\n  this._opts.encodings = this._opts.encodings || {};\n  this._opts.defaultEncoding = this._opts.defaultEncoding || \"utf8\";\n  this._opts.noAckBatchOptions = this._opts.noAckBatchOptions || { noAckBatchSize: null, noAckBatchAge: null };\n\n  this._knowntopics = [];\n  this._subs_counter = new SubsCounter();\n  this._qlobber_opts = {separator: '_',  wildcard_one: '*', wildcard_some: '#'};\n  this._subs_matcher = new Qlobber(this._qlobber_opts);\n\n  this._ascoltatore = new TrieAscoltatore(opts);\n  this._consumerStarting = false;\n  var connectionString = this._opts.connectionString || this._default_opts.connectionString;\n  var clientId = this._opts.clientId || this._default_opts.clientId;\n  var zkOptions = this._opts.zkOptions || this._default_opts.zkOptions;\n  var noAckBatchOptions = this._opts.noAckBatchOptions;\n  var Client = this._opts.kafka.Client;\n  this._producerClient = new Client(connectionString,clientId,zkOptions,noAckBatchOptions);\n  var HighLevelProducer = this._opts.kafka.HighLevelProducer;\n  this._producer = new HighLevelProducer(this._producerClient);\n  var that = this;\n  this._producer.on('ready',function(){\n     that.readZkTopics(function(err,topics){\n        if(err){\n           that.emit(\"error\",err);\n           return;\n        }\n       that._knowntopics = that._knowntopics.concat(topics);\n       that.emit(\"ready\");\n      });\n   });\n}\n\n/**\n * KafkaAscoltatore inherits from AbstractAscoltatore\n *\n * @api private\n */\nKafkaAscoltatore.prototype = Object.create(AbstractAscoltatore.prototype);\n\nKafkaAscoltatore.prototype.withTopicPartitionsExpanded = function withTopicPartitionsExpanded(client,topics,callback){\n  var that = this;\n  var wanted = [];\n  topics.forEach(function(t){\n     wanted.push(t.topic);\n  });\n  client.loadMetadataForTopics(wanted, function(err, results) {\n       if(err){\n          callback(err,null);\n          return;\n       }\n       var metadata = results[1].metadata;\n       var partitions = [];\n       for(var i=0;i<topics.length;i++){\n           var topic = topics[i].topic;\n           if (topic in metadata){\n             var dictionary = metadata[topic];\n             for (var key in dictionary) {\n               if (dictionary.hasOwnProperty(key)) {\n                  partitions.push({topic: topic, partition: dictionary[key].partition, time: -1, maxNum: 1});\n               }\n             }\n           }\n       }\n       callback(null,partitions);\n   });\n};\nKafkaAscoltatore.prototype.withTopicOffsetsAdded = function withTopicOffsetsAdded(client,topics,callback){\n     var that = this;\n     this.withTopicPartitionsExpanded(client, topics, function(err, partitions){\n       if(err){\n           callback(err,null);\n           return;\n       }\n       for(var i=0;i<partitions.length;i++){\n          partitions[i].time = -1;\n          partitions[i].maxNum = 1;\n       }\n       var kafka = that._opts.kafka;\n       var offset = new kafka.Offset(client);\n       offset.fetch(partitions, function (err, data) {\n           if(err){\n             callback(err,null);\n             return;\n           }\n           var offsets = [];\n           for (var topic in data) {\n             if (data.hasOwnProperty(topic)) {\n                for(var partition in data[topic]){\n                   if(data[topic].hasOwnProperty(partition)){\n                      offsets.push({topic: topic, partition: parseInt(partition), offset: data[topic][partition][0]});\n                   }\n                }\n             }\n           }\n           callback(null,offsets);\n       });\n   });\n};\n\n/**\n * Starts a new connection to an Kafka server.\n * Do nothing if it is already started.\n *\n * @api private\n */\nKafkaAscoltatore.prototype._startConn = function(cb) {\n  var that = this;\n  if (this._consumer !== undefined) {\n      return;\n  }\n   this._consumerStarting = true;\n   var newcb = function(){\n          that._consumerStarting = false;\n          util.wrap(cb)();\n          that.emit(\"consumer_connected\");\n   };\n   var connectionString = that._opts.connectionString || that._default_opts.connectionString;\n   var clientId = that._opts.clientId || that._default_opts.clientId;\n   var zkOptions = that._opts.zkOptions || that._default_opts.zkOptions;\n   var noAckBatchOptions = that._opts.noAckBatchOptions;\n   var groupId = that._opts.groupId || that._default_opts.groupId;\n   var Client = this._opts.kafka.Client;\n   var useHighLevelConsumer = that._opts.useHighLevelConsumer || false;\n   var HighLevelConsumer = this._opts.kafka.HighLevelConsumer;\n   var Consumer = this._opts.kafka.Consumer;\n   var subscribedTopics = that._subs_counter.keys();\n   var subscriptions = [];\n   subscribedTopics.forEach(function(topic){\n        subscriptions.push({topic: topic, offset: -1});\n   });\n   debug(\"consumer connecting with connectionString=[\"+connectionString+\"], clientId=[\"+clientId+\"], groupId=[\"+groupId+\"] and initial subscriptions\",subscriptions);\n   this._consumerClient = new Client(connectionString,clientId,zkOptions,noAckBatchOptions);\n   var initConsumer = function(err,subscriptions){\n        if(err){\n          debug(\"problem with initConsumer\",err);\n          that.emit(\"error\", err);\n          return false;\n        }\n        debug(\"initial subscriptions expanded to \",subscriptions);\n        if (useHighLevelConsumer) {\n           debug(\"Using high level consumer \");\n           that._consumer = new HighLevelConsumer(that._consumerClient, subscriptions, {\n               groupId: groupId,fromOffset: true, autoCommit: false, encoding: \"buffer\"\n           });\n        } else {\n           debug(\"Using simple consumer \");\n           that._consumer = new Consumer(that._consumerClient, subscriptions, {\n               groupId: groupId,fromOffset: true, autoCommit: false, encoding: \"buffer\"});\n        }\n        that._consumer.on(\"message\", function(message) {\n            debug(\"received new message on topic \", message.topic);\n            var value = message.value;\n            var encoding = that._opts.encodings[message.topic] || that._opts.defaultEncoding;\n            if(message.value && encoding !== \"buffer\"){\n              value = message.value.toString(encoding);\n              debug(\"message is\", value);\n            }\n            if(that._ascoltatore._closed !== true){\n              debug(\"publishing to _ascolatore \", message.topic);\n              that._ascoltatore.publish(that._recvTopic(message.topic), value);\n            }\n        });\n        that._consumer.on('error', function(e) {\n          debug(\"error in client\",e);\n          that.emit(\"error\", e);\n        });\n        defer(newcb);\n    };\n    that._consumerClient.on('ready',function() {\n        that.withTopicOffsetsAdded(that._consumerClient,subscriptions,initConsumer);\n    });\n};\n\nKafkaAscoltatore.prototype.subscribe = function subscribe(topic, onMessageReceived, done) {\n  this._raiseIfClosed();\n  var that = this;\n  if(this._consumerStarting){\n     debug(\"waiting for consumer_connected before subscribing\");\n     this.on(\"consumer_connected\",function(){ that.subscribe(topic,onMessageReceived,done); });\n     return;\n  }\n\n  debug(\"subscribe called for \",topic);\n  var subtopic = this._subTopic(topic);\n  this._subs_matcher.add(subtopic,'x');\n  var matcher = new Qlobber(this._qlobber_opts);\n  matcher.add(subtopic,'wanted');\n  var subscribe_topics = [];\n  for (var i=0, l=this._knowntopics.length; i<l; i++){\n    var top = this._knowntopics[i];\n    if(matcher.match(top).length > 0){\n      if(!(that._subs_counter.include(top))){\n        subscribe_topics.push({topic: top});\n      }\n      that._subs_counter.add(top);\n    }\n  }\n\n  this._ascoltatore.subscribe(topic, onMessageReceived);\n  if(subscribe_topics.length === 0){\n     defer(done);\n     return;\n  }\n\n  if(this._consumer === undefined){\n    this._startConn(done);\n    return;\n  }\n\n  this.addKafkaSubscriptions(subscribe_topics, done);\n};\n\nKafkaAscoltatore.prototype.addKafkaSubscriptions = function addKafkaSubscriptions(subscribe_topics, done) {\n  var that = this;\n  debug(\"registering new subscriber for topics \", subscribe_topics);\n  this.withTopicOffsetsAdded(this._consumerClient,subscribe_topics,function(err,subscriptions){\n          if(err){\n            debug(\"problem adding kafka subscriptions with topic offsets added\",err);\n            that.emit(\"error\",err);\n            return;\n          }\n          that._consumer.addTopics(subscriptions,function(err,added) {\n                if(err){\n                  debug(\"problem with consumer.addTopics\",err);\n                  that.emit(\"error\",err);\n                  return;\n                }\n                debug(\"registered new kafka subscriptions\", subscribe_topics);\n                defer(done);\n              },true);\n    });\n};\n\nKafkaAscoltatore.prototype.publish = function publish(topic, message, done) {\n  this._raiseIfClosed();\n  var that = this;\n  // kafka cannot send a null message. Why are messages missing in the tests...\n  if(message === undefined || message === null){\n    message = '';\n  }\n  var pubtopic = this._pubTopic(topic);\n  var doPublish = function(){\n    var payload = {\n      messages: message,\n      topic: pubtopic\n    };\n    debug(\"about to publish new message to \",pubtopic);\n    that._producer.send([payload], function(err,data) {\n      if(err){\n        debug(\"something went wrong publishing to \"+pubtopic,err);\n        that.emit(\"error\",err);\n      }else{\n        debug(\"new message published to \" + pubtopic);\n      }\n      util.wrap(done)();\n    });\n  };\n\n  if(this._knowntopics.indexOf(pubtopic) >= 0){\n     //we already know about this topic, so publish to it and we're done.\n     doPublish();\n     return;\n  }\n\n  // it's a new topic for kafka\n  var createTopicCallback = function(err){\n         if(err){\n            debug(\"problem creating topic\",err);\n            that.emit(\"error\",err);\n            return;\n         }\n         //do subscribers await this new topic?\n         var wanted = that._subs_matcher.match(pubtopic);\n         if(wanted.length === 0){\n             // nobody subscribed at our end, so just publish to kafka\n             doPublish();\n             return;\n         }\n         // somebody wants messages published to the new topic\n         for(var i=0;i<wanted.length;i++){\n            that._subs_counter.add(pubtopic);\n         }\n         if(that._consumer === undefined){\n            // start the kafka consumer before publishing\n            // starting the consumer will add the subscription\n            that._startConn(doPublish);\n            return;\n         }\n         // the kafka consumer is already running\n         // just add the new subscriptions before publishing\n         that.addKafkaSubscriptions([{topic: pubtopic}], function(){\n             debug(\"publish route 4\");\n             doPublish();\n         });\n     };\n  this.createTopics(pubtopic, createTopicCallback);\n};\n\nKafkaAscoltatore.prototype.unsubscribe = function unsubscribe(topic, callback, done) {\n  this._raiseIfClosed();\n  var that = this;\n\n  var subtopic = this._subTopic(topic);\n\n  var newDone = function() {\n    debug(\"deregistered subscriber for topic \" + subtopic);\n    defer(done);\n  };\n\n  this._subs_matcher.remove(subtopic);\n  this._ascoltatore.unsubscribe(topic, callback);\n  if(this._consumerClient === undefined){\n    newDone();\n    return;\n  }\n\n  var matcher = new Qlobber(this._qlobber_opts);\n  matcher.add(subtopic,'unwanted');\n  var unsubscribe_topics = [];\n  for (var i=0, l=this._knowntopics.length; i<l; i++){\n    var top = this._knowntopics[i];\n    if(matcher.match(top).length > 0){\n      that._subs_counter.remove(top);\n      if(!(that._subs_counter.include(top))){\n        unsubscribe_topics.push({topic: top});\n      }\n    }\n  }\n\n  if(unsubscribe_topics.length === 0 ) {\n    newDone();\n    return;\n  }\n\n  debug(\"deregistering subscriber for topic \" + unsubscribe_topics);\n  this.withTopicPartitionsExpanded(this._consumerClient,unsubscribe_topics,function(err,partitions){\n      if(err){\n        debug(\"problem expanding topics before unsubscribe\",err);\n        that.emit(\"error\",err);\n        return;\n      }\n      that._consumer.removeTopics(partitions,function(err,removed){ \n          if(err){\n            debug(\"problem removing topics\",err);\n            that.emit(\"error\",err);\n            return;\n          }\n          newDone();\n       });\n  });\n};\n\nKafkaAscoltatore.prototype.readZkTopics = function readZkTopics(callback){\n  var that = this;\n  this._raiseIfClosed();\n   this._producerClient.zk.client.getChildren(\"/config/topics\", function (error, children, stats) {\n     if (error) {\n         callback(error,null);\n         return;\n     }\n     callback(null,children);\n   });\n};\n\nKafkaAscoltatore.prototype.createTopics = function createTopics(topics,callback){\n  var that = this;\n  if(typeof topics === 'string'){\n     topics = [topics];\n  }\n  debug(\"creating topics \",topics);\n  this._producer.createTopics(topics, false, function (err, data) {\n         if(err){\n            debug(\"problem creating topics\",err);\n            defer(function(){callback(err);});\n            return;\n         }\n         that._knowntopics = that._knowntopics.concat(topics);\n         defer(callback);\n    });\n};\n\nKafkaAscoltatore.prototype.close = function close(done) {\n  var that = this;\n  debug(\"closing\");\n  if (!this._closed) {\n    this._subs_counter.clear();\n    if(this._producer){\n      this._producer.close(function(){\n        that._producerClient.close(function() {\n          debug(\"closed producer\");\n          delete that._producerClient;\n          delete that._producer;\n        });\n      });\n    }\n    if(this._consumer){\n       that._consumer.close(function(){\n        debug(\"closed consumer\");\n        that._consumerClient.close(function() {\n          debug(\"closed\");\n          that._ascoltatore.close();\n          delete that._consumerClient;\n          delete that._consumer;\n          that.emit(\"closed\");\n          defer(done);\n        });\n     });\n    }else{\n      this.emit(\"closed\");\n      util.wrap(done)();\n    }\n  } else {\n    util.wrap(done)();\n  }\n};\n\nutil.aliasAscoltatore(KafkaAscoltatore.prototype);\n\n/**\n * Exports the KafkaAscoltatore\n *\n * @api public\n */\nmodule.exports = KafkaAscoltatore;\n","/home/travis/build/npmtest/node-npmtest-ascoltatori/node_modules/ascoltatori/lib/behave_like_an_ascoltatore.js":"\"use strict\";\n\nvar wrap = require(\"./util\").wrap;\nvar steed = require(\"steed\")();\n\n/**\n * This is a shared mocha test for verifying that an\n * ascoltatore is behaving like one.\n *\n * This requires that the test exposes an instance property\n * on `this`.\n *\n * See as an example:\n * https://github.com/mcollina/ascoltatori/blob/master/test/redis_ascoltatore_spec.js\n *\n * @api public\n */\nmodule.exports = function() {\n\n  var expect;\n\n  // you MUST depend on chai only if you plan to run\n  // this test\n  expect = require(\"chai\").expect;\n\n  it(\"should have a subscribe function\", function() {\n    var that = this;\n    expect(that.instance).to.respondTo(\"subscribe\");\n  });\n\n  it(\"should have an publish function\", function() {\n    var that = this;\n    expect(that.instance).to.respondTo(\"publish\");\n  });\n\n  it(\"should support a publish/subscribe pattern\", function(done) {\n    var that = this;\n    that.instance.subscribe(\"hello\", wrap(done), function() {\n      that.instance.publish(\"hello\");\n    });\n  });\n\n  it(\"should support 'pub/sub' combination for pub/sub\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello\", wrap(done), function() {\n      that.instance.pub(\"hello\");\n    });\n  });\n\n  it(\"should not raise an exception if pub is called without a done callback\", function(done) {\n    this.instance.pub(\"hello\");\n    setTimeout(done, 50);\n  });\n\n  it(\"should not raise an exception if sub is called without a done callback\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello\", function() {});\n    setTimeout(function() {\n      // still, some Ascoltatore are async\n      // and we must give them some time\n      done();\n    }, 10);\n  });\n\n  it(\"should accept a done callback in pub\", function(done) {\n    this.instance.pub(\"hello\", \"world\", done);\n  });\n\n  it(\"should support multi-level wildcard at end of topic\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello/*\", wrap(done), function() {\n      that.instance.pub(\"hello/there/42\");\n    });\n  });\n\n  it(\"should support multi-level wildcard at the end of a topic with no separator\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello/*\", wrap(done), function() {\n      that.instance.pub(\"hello\");\n    });\n  });\n\n  it(\"should support single-level wildcard at start of topic\", function(done) {\n    var that = this;\n    that.instance.sub(\"+/hello\", wrap(done), function() {\n      that.instance.pub(\"42/hello\");\n    });\n  });\n\n  it(\"should support single-level wildcard in middle of topic\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello/+/end\", wrap(done), function() {\n      that.instance.pub(\"hello/42/end\");\n    });\n  });\n\n  it(\"should support single-level wildcard at end of topic\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello/+\", wrap(done), function() {\n      that.instance.pub(\"hello/42\");\n    });\n  });\n\n  it(\"should support both wildcards in topic\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello/+/there/*\", wrap(done), function() {\n      that.instance.pub(\"hello/foo/there/bar/42/end\");\n    });\n  });\n\n  it(\"should not match multiple levels with single wildcard\", function(done) {\n    var that = this,\n        callback = null;\n\n    callback = function(topic) {\n      expect(topic).to.equal([\"hello\", \"42\", \"there\"].join(that.separator));\n      done();\n    };\n\n    that.instance.sub(\"hello/+/there\", callback, function () {\n      that.instance.pub(\"hello/42/43/there\");\n      that.instance.pub(\"hello/42/there\");\n    });\n  });\n\n  it(\"should unsubscribe from wildcard topics independently\", function(done) {\n    var that = this,\n        callback1 = null,\n        callback2 = null;\n\n    callback1 = function(topic) {\n      expect(topic).to.equal([\"hello\", \"42\", \"there\"].join(that.separator));\n      done();\n    };\n\n    callback2 = function () { };\n\n    that.instance.sub(\"hello/*/there\", callback2, function () {\n      that.instance.sub(\"hello/+/there\", callback1, function () {\n        that.instance.unsub(\"hello/*/there\", callback2, function () {\n          that.instance.pub(\"hello/42/there\");\n        });\n      });\n    });\n  });\n\n  it(\"should call each matching callback\", function(done) {\n    var that = this,\n        callback = null,\n        count = 0;\n\n    callback = function(topic) {\n      expect(topic).to.equal([\"hello\", \"42\"].join(that.separator));\n      count += 1;\n      if (count === 2) {\n        done();\n      }\n    };\n\n    that.instance.sub(\"hello/42\", callback, function () {\n      that.instance.sub(\"hello/*\", callback, function () {\n        that.instance.pub(\"hello/42\");\n      });\n    });\n  });\n\n  it(\"should publish the topic name\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello/*\", function(topic) {\n      expect(topic).to.equal([\"hello\", \"42\"].join(that.separator));\n      done();\n    }, function() {\n      that.instance.pub(\"hello/42\");\n    });\n  });\n\n  it(\"should publish the passed argument\", function(done) {\n    var that = this;\n    that.instance.sub(\"hello/*\", function(topic, value) {\n      expect(value.toString()).to.equal(\"42\");\n      done();\n    }, function() {\n      that.instance.pub(\"hello/123\", \"42\");\n    });\n  });\n\n  it(\"should have an unsubscribe function\", function() {\n    var that = this;\n    expect(that.instance).to.respondTo(\"unsubscribe\");\n  });\n\n  it(\"should have an unsub function\", function() {\n    var that = this;\n    expect(that.instance).to.respondTo(\"unsub\");\n  });\n\n  it(\"should remove a listener\", function(done) {\n    var that = this;\n    var funcToRemove = null;\n\n    funcToRemove = function(topic, value) {\n      throw \"that should never run\";\n    };\n    steed.series([\n\n      function(cb) {\n        that.instance.sub(\"hello\", funcToRemove, cb);\n      },\n\n      function(cb) {\n        that.instance.sub(\"hello\", wrap(done), cb);\n      },\n\n      function(cb) {\n        that.instance.unsub(\"hello\", funcToRemove, cb);\n      },\n\n      function(cb) {\n        that.instance.pub(\"hello\", null, cb);\n      }\n    ]);\n  });\n\n  it(\"should remove a listener for global searches\", function(done) {\n    var that = this,\n      funcToRemove = null;\n    funcToRemove = function(topic, value) {\n      throw \"that should never run\";\n    };\n    steed.series([\n\n      function(cb) {\n        that.instance.sub(\"hello/42\", wrap(done), cb);\n      },\n\n      function(cb) {\n        that.instance.sub(\"hello/*\", funcToRemove, cb);\n      },\n\n      function(cb) {\n        that.instance.unsub(\"hello/*\", funcToRemove, cb);\n      },\n\n      function(cb) {\n        that.instance.pub(\"hello/42\", null, cb);\n      }\n    ]);\n  });\n\n  it(\"support at least 10 listeners\", function(done) {\n    var instance = this.instance,\n      counter = 11,\n      i = null,\n      callback = null,\n      subscribe = null,\n      a = [];\n\n    callback = function() {\n      counter = counter - 1;\n      if (counter === 0) {\n        done();\n      }\n    };\n\n    subscribe = function (done) {\n      instance.subscribe(\"hello\", callback, done);\n    };\n\n    for (i = counter; i > 0; i = i - 1) {\n      a.push(subscribe);\n    }\n\n    steed.parallel(a, instance.publish.bind(instance, \"hello\", null));\n  });\n\n  it(\"should emit the ready event\", function(done) {\n    this.instance.on(\"ready\", done);\n  });\n\n  it(\"should support at least 12 listeners as an EventEmitter\", function(done) {\n    var counter = 11,\n      i = null,\n      callback, a = [];\n\n    callback = function() {\n      counter = counter - 1;\n      if (counter === 0) {\n        done();\n      }\n    };\n\n    for (i = counter; i > 0; i = i - 1) {\n      a.push(this.instance.on.bind(this.instance, \"ready\", callback));\n    }\n    steed.parallel(a);\n  });\n\n  it(\"should support removing a single listener\", function(done) {\n    var that = this,\n      funcToRemove;\n\n    funcToRemove = function(topic, value) {\n      throw \"that should never run\";\n    };\n    steed.series([\n\n      function(cb) {\n        that.instance.sub(\"hello\", wrap(done), cb);\n      },\n\n      function(cb) {\n        that.instance.sub(\"hello\", funcToRemove, cb);\n      },\n\n      function(cb) {\n        that.instance.unsub(\"hello\", funcToRemove, cb);\n      },\n\n      function(cb) {\n        that.instance.pub(\"hello\", null, cb);\n      }\n    ]);\n  });\n\n  it(\"should have a close function\", function() {\n    var that = this;\n    expect(that.instance).to.respondTo(\"close\");\n  });\n\n  it(\"should throw an error if publishing when the ascoltatore has been closed\", function(done) {\n    this.instance.close(function() {\n      expect(function() {\n        this.instance.publish(\"hello\", \"world\");\n      }).to.throw;\n      done();\n    });\n  });\n\n  it(\"should throw an error if subscribing when the ascoltatore has been closed\", function(done) {\n    this.instance.close(function() {\n      expect(function() {\n        this.instance.subscribe(\"hello\");\n      }).to.throw;\n      done();\n    });\n  });\n\n  it(\"should close using a callback\", function(done) {\n    var that = this;\n    this.instance.publish(\"hello\", \"world\", function() {\n      that.instance.close(done);\n    });\n  });\n\n  it(\"should allow the close method to be called twice\", function(done) {\n    var that = this;\n    steed.series([\n      this.instance.publish.bind(this.instance, \"hello\", \"world\"),\n      this.instance.close.bind(this.instance),\n      this.instance.close.bind(this.instance)\n    ], done);\n  });\n\n  it(\"should not deliver message twice for double subscription\", function(done) {\n    var that = this,\n      count = 2,\n      sub = null,\n      d = null;\n\n    d = function() {\n      count = count - 1;\n      if (count === 0) {\n        done();\n      }\n    };\n\n    sub = function(cb) {\n      var called = false;\n      that.instance.sub(\"hello\", function() {\n        expect(called).to.be.equal(false);\n        called = true;\n        d();\n      }, cb);\n    };\n\n    steed.series([\n      sub, sub,\n\n      function(cb) {\n        that.instance.pub(\"hello\", \"ahha\", cb);\n      }\n    ]);\n  });\n\n  it(\"should not deliver message twice for multiple subscriptions using wildcards\", function(done) {\n    var that = this,\n      count = 3,\n      sub = null,\n      d = null;\n\n    d = function() {\n      count = count - 1;\n      if (count === 0) {\n        done();\n      }\n    };\n\n    sub = function(topic, cb) {\n      var called = false;\n      that.instance.sub(topic, function() {\n        expect(called).to.equal(false);\n        called = true;\n        d();\n      }, cb);\n    };\n\n    steed.series([\n      function (cb) {\n        sub(\"a/+\", cb);\n      },\n      function (cb) {\n        sub(\"+/b\", cb);\n      },\n      function (cb) {\n        sub(\"a/b\", cb);\n      },\n      function(cb) {\n        that.instance.pub(\"a/b\", \"ahha\", cb);\n      }\n    ]);\n  });\n};\n"}